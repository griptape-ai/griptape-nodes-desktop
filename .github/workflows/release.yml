name: Release

on:
  workflow_dispatch:
    inputs:
      channel:
        description: 'Release channel (stable, beta, dev, etc.) - defaults to branch name'
        required: false
        type: string
      destination:
        description: 'Distribution destination'
        required: true
        type: choice
        options:
          - github
          - s3
        default: github

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.check.outputs.should_proceed }}
      channel: ${{ steps.check.outputs.channel }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Check for existing release
        id: check
        shell: bash
        run: |
          # Determine channel from input or branch name
          CURRENT_BRANCH="${{ github.ref_name }}"

          if [[ -n "${{ inputs.channel }}" ]]; then
            CHANNEL="${{ inputs.channel }}"
          elif [[ "$CURRENT_BRANCH" == "main" ]]; then
            CHANNEL="stable"
          else
            # Sanitize branch name for use as channel (replace / with -)
            CHANNEL=$(echo "$CURRENT_BRANCH" | sed 's/\//-/g')
          fi

          echo "Current branch: $CURRENT_BRANCH"
          echo "Channel: $CHANNEL"

          # Set outputs
          echo "channel=$CHANNEL" >> $GITHUB_OUTPUT

          # Note: Tag validation will be done per-platform during upload step
          # since we now have platform-specific channels and tags
          echo "Channel validation passed"
          echo "should_proceed=true" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release:
    needs: validate
    runs-on: ${{ matrix.os }}

    permissions:
      id-token: write  # required for OIDC
      contents: write  # Required to create new releases with GITHUB_TOKEN

    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, windows-latest]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Configure AWS creds via OIDC
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::246367841364:role/GriptapeNodesDesktopGithubActions
          aws-region: us-west-2
          role-session-name: gha-${{ github.run_id }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'

      - name: Check if tag already exists
        run: |
          USER_CHANNEL="${{ needs.validate.outputs.channel }}"
          VERSION=$(node -p "require('./package.json').version")

          # Determine OS and architecture for channel naming
          if [ "$RUNNER_OS" == "Linux" ]; then
            OS="linux"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "aarch64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "macOS" ]; then
            OS="osx"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "arm64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "Windows" ]; then
            OS="win"
            ARCH="x64"
          fi

          FULL_CHANNEL="${OS}-${ARCH}-${USER_CHANNEL}"

          # Tag naming logic
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            TAG_NAME="v${VERSION}-${OS}-${ARCH}"
          else
            TAG_NAME="v${VERSION}-${FULL_CHANNEL}"
          fi

          echo "Checking for existing tag: $TAG_NAME"

          # Check if tag exists on GitHub
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "Tag $TAG_NAME already exists, skipping build for this platform"
            echo "DONE=true" >> $GITHUB_ENV
          else
            echo "Tag $TAG_NAME does not exist, proceeding with build"
            echo "DONE=false" >> $GITHUB_ENV
          fi
        shell: bash

      - name: Setup .NET
        if: env.DONE != 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.x

      - name: Install Velopack CLI
        if: env.DONE != 'true'
        run: dotnet tool install -g vpk

      - name: Install Dependencies
        if: env.DONE != 'true'
        run: npm ci

      - name: Setup platform variables
        if: env.DONE != 'true'
        id: platform
        run: |
          USER_CHANNEL="${{ needs.validate.outputs.channel }}"

          # Determine OS and architecture for channel naming
          if [ "$RUNNER_OS" == "Linux" ]; then
            OS="linux"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "aarch64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "macOS" ]; then
            OS="osx"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "arm64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "Windows" ]; then
            OS="win"
            ARCH="x64"
          fi

          # Construct full channel name: {os}-{arch}-{channel}
          FULL_CHANNEL="${OS}-${ARCH}-${USER_CHANNEL}"

          # Set environment variables for subsequent steps
          echo "OS=$OS" >> $GITHUB_ENV
          echo "ARCH=$ARCH" >> $GITHUB_ENV
          echo "USER_CHANNEL=$USER_CHANNEL" >> $GITHUB_ENV
          echo "FULL_CHANNEL=$FULL_CHANNEL" >> $GITHUB_ENV

          echo "Platform: $OS-$ARCH"
          echo "Channel: $USER_CHANNEL"
          echo "Full channel: $FULL_CHANNEL"
        shell: bash

      - name: Install Apple certificates and notary profile
        if: env.DONE != 'true' && runner.os == 'macOS' && env.MAC_CERTS_P12 != ''
        env:
          MAC_CERTS_P12: ${{ secrets.MAC_CERTS_P12 }}
          MAC_CERTS_PASSWORD: ${{ secrets.MAC_CERTS_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # create variables for file paths
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # import certificate from secrets
          echo -n "$MAC_CERTS_P12" | base64 --decode -o $CERTIFICATE_PATH

          # create temporary keychain
          security create-keychain -p "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MAC_CERTS_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # create notarytool profile using keychain
          xcrun notarytool store-credentials --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APPLE_PASSWORD" --keychain "$KEYCHAIN_PATH" velopack-profile

      - name: Download previous Velopack releases
        if: env.DONE != 'true'
        run: |
          echo "Downloading previous releases for channel: $FULL_CHANNEL"

          if [ "${{ inputs.destination }}" == "github" ]; then
            vpk download github --repoUrl https://github.com/${{ github.repository }} --token ${{ secrets.GITHUB_TOKEN }} --channel "$FULL_CHANNEL"
          else
            vpk download s3 --bucket griptape-nodes-desktop-updates --region us-west-2 --channel "$FULL_CHANNEL"
          fi
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Build with Velopack
        if: env.DONE != 'true'
        run: |
          echo "Building for channel: $FULL_CHANNEL"

          if [ "$RUNNER_OS" == "Linux" ]; then
            ./scripts/build-linux.sh "$FULL_CHANNEL"
          elif [ "$RUNNER_OS" == "macOS" ]; then
            ./scripts/build-osx.sh "$FULL_CHANNEL"
          elif [ "$RUNNER_OS" == "Windows" ]; then
            powershell -ExecutionPolicy Bypass -File ./scripts/build-windows.ps1 -Channel "$FULL_CHANNEL"
          fi
        shell: bash
        env:
          MAC_CERTS_P12: ${{ secrets.MAC_CERTS_P12 }}

      - name: Upload Velopack releases
        if: env.DONE != 'true'
        run: |
          VERSION=$(node -p "require('./package.json').version")

          # Tag and release naming
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            TAG_NAME="v${VERSION}-${OS}-${ARCH}"
            RELEASE_NAME="Griptape Nodes Desktop ${VERSION} (${OS}-${ARCH})"
          else
            TAG_NAME="v${VERSION}-${FULL_CHANNEL}"
            RELEASE_NAME="Griptape Nodes Desktop ${VERSION} (${FULL_CHANNEL})"
          fi

          echo "Uploading for channel: $FULL_CHANNEL"
          echo "Tag: $TAG_NAME"
          echo "Release name: $RELEASE_NAME"

          if [ "${{ inputs.destination }}" == "github" ]; then
            vpk upload github \
              --repoUrl https://github.com/${{ github.repository }} \
              --publish \
              --releaseName "$RELEASE_NAME" \
              --tag "$TAG_NAME" \
              --channel "$FULL_CHANNEL" \
              --token ${{ secrets.GITHUB_TOKEN }}
          else
            vpk upload s3 --bucket griptape-nodes-desktop-updates --region us-west-2 --channel "$FULL_CHANNEL"
          fi
        shell: bash
        env:
          AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY_ID }}
          AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}

      - name: Clean up keychain
        if: runner.os == 'macOS' && always()
        run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db

      - name: Upload GitHub Release Assets
        if: env.DONE != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: releases-${{ runner.os }}-${{ runner.arch }}
          path: Releases/
