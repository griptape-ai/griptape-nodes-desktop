name: Release

on:
  workflow_dispatch:
    inputs:
      channel:
        description: 'Release channel (stable, beta, dev, etc.) - defaults to stable for main and branch name otherwise'
        required: false
        type: string
      skip_s3_upload:
        description: 'Skip S3 upload (for test builds without auto-updates). Defaults to true for non-main branches.'
        required: false
        type: boolean
        default: false

jobs:
  validate:
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.check.outputs.should_proceed }}
      channel: ${{ steps.check.outputs.channel }}
      skip_s3_upload: ${{ steps.check.outputs.skip_s3_upload }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          lfs: true

      - name: Check for existing release
        id: check
        shell: bash
        run: |
          # Determine channel from input or branch name
          CURRENT_BRANCH="${{ github.ref_name }}"

          if [[ -n "${{ inputs.channel }}" ]]; then
            CHANNEL="${{ inputs.channel }}"
          elif [[ "$CURRENT_BRANCH" == "main" ]]; then
            CHANNEL="stable"
          else
            # Sanitize branch name for use as channel (replace / with -)
            CHANNEL=$(echo "$CURRENT_BRANCH" | sed 's/\//-/g')
          fi

          echo "Current branch: $CURRENT_BRANCH"
          echo "Channel: $CHANNEL"

          # Validate: channel must be "stable" if and only if branch is "main"
          if [[ "$CURRENT_BRANCH" == "main" && "$CHANNEL" != "stable" ]]; then
            echo "ERROR: Branch 'main' requires channel to be 'stable', but got '$CHANNEL'"
            exit 1
          elif [[ "$CURRENT_BRANCH" != "main" && "$CHANNEL" == "stable" ]]; then
            echo "ERROR: Channel 'stable' can only be used from branch 'main', but current branch is '$CURRENT_BRANCH'"
            exit 1
          fi

          # Set outputs
          echo "channel=$CHANNEL" >> $GITHUB_OUTPUT

          # Determine if we should skip S3 upload
          # - If user explicitly set skip_s3_upload, use that value
          # - Otherwise, auto-skip for non-stable channels (non-main branches)
          if [[ "${{ inputs.skip_s3_upload }}" == "true" ]]; then
            SKIP_S3="true"
            echo "S3 upload will be skipped (explicitly requested)"
          elif [[ "$CHANNEL" != "stable" ]]; then
            SKIP_S3="true"
            echo "S3 upload will be skipped (non-stable channel defaults to skip)"
          else
            SKIP_S3="false"
            echo "S3 upload will proceed (stable channel)"
          fi
          echo "skip_s3_upload=$SKIP_S3" >> $GITHUB_OUTPUT

          # Note: Tag validation will be done per-platform during upload step
          # since we now have platform-specific channels and tags
          echo "Channel validation passed"
          echo "should_proceed=true" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  release:
    needs: validate
    runs-on: ${{ matrix.os }}

    permissions:
      id-token: write # required for OIDC
      contents: write # Required to create new releases with GITHUB_TOKEN

    strategy:
      matrix:
        os: [macos-latest, ubuntu-latest, ubuntu-24.04-arm, windows-latest]

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}
          lfs: true

      - name: Setup platform variables and check for existing release
        id: platform
        run: |
          USER_CHANNEL="${{ needs.validate.outputs.channel }}"
          VERSION=$(jq -r .version package.json)

          # Determine OS and architecture for channel naming
          if [ "$RUNNER_OS" == "Linux" ]; then
            OS="linux"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "aarch64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "macOS" ]; then
            OS="osx"
            ARCH=$(uname -m)
            if [[ "$ARCH" == "arm64" ]]; then
              ARCH="arm64"
            else
              ARCH="x64"
            fi
          elif [ "$RUNNER_OS" == "Windows" ]; then
            OS="win"
            ARCH="x64"
          fi

          FULL_CHANNEL="${OS}-${ARCH}-${USER_CHANNEL}"

          # Export platform variables for subsequent steps
          echo "OS=$OS" >> $GITHUB_ENV
          echo "ARCH=$ARCH" >> $GITHUB_ENV
          echo "USER_CHANNEL=$USER_CHANNEL" >> $GITHUB_ENV
          echo "FULL_CHANNEL=$FULL_CHANNEL" >> $GITHUB_ENV

          echo "Platform: $OS-$ARCH"
          echo "Channel: $USER_CHANNEL"
          echo "Full channel: $FULL_CHANNEL"

          # Tag naming logic
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            TAG_NAME="v${VERSION}-${OS}-${ARCH}"
          else
            TAG_NAME="v${VERSION}-${FULL_CHANNEL}"
          fi

          echo "Checking for existing tag: $TAG_NAME"

          # Check if tag exists on GitHub
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME$"; then
            echo "Tag $TAG_NAME already exists, skipping build for this platform"
            echo "DONE=true" >> $GITHUB_ENV
          else
            echo "Tag $TAG_NAME does not exist, proceeding with build"
            echo "DONE=false" >> $GITHUB_ENV
          fi
        shell: bash

      - name: Configure AWS creds via OIDC
        if: env.DONE != 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: arn:aws:iam::246367841364:role/GriptapeNodesDesktopGithubActions
          aws-region: us-west-2
          role-session-name: gha-${{ github.run_id }}

      - name: Setup Node.js
        if: env.DONE != 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '24'
          cache: 'npm'

      - name: Setup .NET
        if: env.DONE != 'true'
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: 9.x

      - name: Install Velopack CLI
        if: env.DONE != 'true'
        run: dotnet tool install -g vpk

      - name: Install Dependencies
        if: env.DONE != 'true'
        run: npm ci

      - name: Generate release notes
        if: env.DONE != 'true'
        run: |
          VERSION=$(jq -r .version package.json)

          # Determine the previous tag for generating notes
          # For stable releases, find the previous stable tag
          # For other channels, this will generate notes from all commits
          PREV_TAG=$(gh release list --limit 1 --json tagName --jq '.[0].tagName' 2>/dev/null || echo "")

          echo "Current version: v${VERSION}"
          echo "Previous tag: ${PREV_TAG:-none}"

          # Use GitHub API to generate release notes content
          if [ -n "$PREV_TAG" ]; then
            NOTES=$(gh api repos/${{ github.repository }}/releases/generate-notes \
              -f tag_name="v${VERSION}" \
              -f target_commitish="${{ github.sha }}" \
              -f previous_tag_name="$PREV_TAG" \
              --jq '.body' 2>/dev/null || echo "")
          else
            NOTES=$(gh api repos/${{ github.repository }}/releases/generate-notes \
              -f tag_name="v${VERSION}" \
              -f target_commitish="${{ github.sha }}" \
              --jq '.body' 2>/dev/null || echo "")
          fi

          # Write to file, with fallback if API fails
          if [ -n "$NOTES" ]; then
            echo "$NOTES" > RELEASE_NOTES.md
            echo "Generated release notes from GitHub API"
          else
            cat << EOF > RELEASE_NOTES.md
          ## What's New in v${VERSION}

          This release includes bug fixes and improvements.

          See the [full changelog](https://github.com/${{ github.repository }}/releases) for details.
          EOF
            echo "Using fallback release notes (API returned empty)"
          fi

          echo "=== Release notes content ==="
          cat RELEASE_NOTES.md
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Install Apple certificates and notary profile
        id: install_certs
        if: env.DONE != 'true' && runner.os == 'macOS' && env.MAC_CERTS_P12 != ''
        env:
          MAC_CERTS_P12: ${{ secrets.MAC_CERTS_P12 }}
          MAC_CERTS_PASSWORD: ${{ secrets.MAC_CERTS_PASSWORD }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          # create variables for file paths
          CERTIFICATE_PATH=$RUNNER_TEMP/build_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db

          # import certificate from secrets
          echo -n "$MAC_CERTS_P12" | base64 --decode -o $CERTIFICATE_PATH

          # create temporary keychain
          security create-keychain -p "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH
          security set-keychain-settings -lut 21600 $KEYCHAIN_PATH
          security unlock-keychain -p "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH

          # import certificate to keychain
          security import $CERTIFICATE_PATH -P "$MAC_CERTS_PASSWORD" -A -t cert -f pkcs12 -k $KEYCHAIN_PATH
          security set-key-partition-list -S apple-tool:,apple: -k "$MAC_CERTS_PASSWORD" $KEYCHAIN_PATH
          security list-keychain -d user -s $KEYCHAIN_PATH

          # create notarytool profile using keychain
          xcrun notarytool store-credentials --apple-id "$APPLE_ID" --team-id "$APPLE_TEAM_ID" --password "$APPLE_PASSWORD" --keychain "$KEYCHAIN_PATH" velopack-profile

      - name: Install AzureSignTool
        if: env.DONE != 'true' && runner.os == 'Windows'
        run: dotnet tool install -g AzureSignTool

      - name: Download previous Velopack releases
        if: env.DONE != 'true' && needs.validate.outputs.skip_s3_upload != 'true'
        run: |
          echo "Downloading previous releases for channel: $FULL_CHANNEL"
          vpk download s3 --bucket griptape-nodes-desktop-releases --region us-west-2 --channel "$FULL_CHANNEL" --prefix "$USER_CHANNEL/"
        shell: bash

      - name: Build with Velopack
        if: env.DONE != 'true'
        run: |
          echo "Building for channel: $FULL_CHANNEL"

          if [ "$RUNNER_OS" == "Linux" ]; then
            ./scripts/build-linux.sh "$FULL_CHANNEL"
          elif [ "$RUNNER_OS" == "macOS" ]; then
            ./scripts/build-osx.sh "$FULL_CHANNEL"
          elif [ "$RUNNER_OS" == "Windows" ]; then
            powershell -ExecutionPolicy Bypass -File ./scripts/build-windows.ps1 -Channel "$FULL_CHANNEL"
          fi
        shell: bash
        env:
          MAC_CERTS_P12: ${{ secrets.MAC_CERTS_P12 }}
          APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
          AZURE_KEY_VAULT_URI: ${{ secrets.AZURE_KEY_VAULT_URI }}
          AZURE_KEY_VAULT_CERTIFICATE_NAME: ${{ secrets.AZURE_KEY_VAULT_CERTIFICATE_NAME }}
          AZURE_KEY_VAULT_CLIENT_ID: ${{ secrets.AZURE_KEY_VAULT_CLIENT_ID }}
          AZURE_KEY_VAULT_CLIENT_SECRET: ${{ secrets.AZURE_KEY_VAULT_CLIENT_SECRET }}
          AZURE_KEY_VAULT_TENANT_ID: ${{ secrets.AZURE_KEY_VAULT_TENANT_ID }}

      - name: Retrieve notarization logs on failure
        if: failure() && runner.os == 'macOS' && env.DONE != 'true'
        run: |
          echo "Retrieving notarization history..."
          xcrun notarytool history --keychain-profile "velopack-profile" --keychain "$RUNNER_TEMP/app-signing.keychain-db" || true

          echo "Fetching detailed log for most recent submission..."
          SUBMISSION_ID=$(xcrun notarytool history --keychain-profile "velopack-profile" --keychain "$RUNNER_TEMP/app-signing.keychain-db" 2>/dev/null | grep -B 2 "status: Invalid" | grep "id:" | head -1 | awk '{print $2}')

          if [ -n "$SUBMISSION_ID" ]; then
            echo "Retrieving log for submission: $SUBMISSION_ID"
            xcrun notarytool log "$SUBMISSION_ID" --keychain-profile "velopack-profile" --keychain "$RUNNER_TEMP/app-signing.keychain-db" notarization_log.json || true

            if [ -f notarization_log.json ]; then
              echo "=== Notarization Log ==="
              cat notarization_log.json
              echo "======================="
            fi
          else
            echo "Could not find submission ID"
          fi
        shell: bash

      - name: Create DMG (macOS only)
        if: env.DONE != 'true' && runner.os == 'macOS'
        run: |
          echo "Creating DMG for channel: $FULL_CHANNEL"
          ./scripts/create-dmg.sh "$FULL_CHANNEL"
        shell: bash

      - name: Upload Velopack releases
        if: env.DONE != 'true' && needs.validate.outputs.skip_s3_upload != 'true'
        run: |
          VERSION=$(node -p "require('./package.json').version")

          # Safety check: prevent accidental S3 upload to stable from non-main
          if [[ "$USER_CHANNEL" == "stable" && "${{ github.ref_name }}" != "main" ]]; then
            echo "ERROR: Refusing to upload stable channel from non-main branch"
            exit 1
          fi

          # Tag and release naming
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            TAG_NAME="v${VERSION}-${OS}-${ARCH}"
            RELEASE_NAME="Griptape Nodes Desktop ${VERSION} (${OS}-${ARCH})"
          else
            TAG_NAME="v${VERSION}-${FULL_CHANNEL}"
            RELEASE_NAME="Griptape Nodes Desktop ${VERSION} (${FULL_CHANNEL})"
          fi

          echo "Uploading for channel: $FULL_CHANNEL"
          echo "Tag: $TAG_NAME"
          echo "Release name: $RELEASE_NAME"

          vpk upload s3 --bucket griptape-nodes-desktop-releases --region us-west-2 --channel "$FULL_CHANNEL" --prefix "$USER_CHANNEL/"
        shell: bash

      - name: Upload DMG to S3 (macOS only)
        if: env.DONE != 'true' && runner.os == 'macOS' && needs.validate.outputs.skip_s3_upload != 'true'
        run: |
          VERSION=$(node -p "require('./package.json').version")
          DMG_FILE="Releases/GriptapeNodes-${VERSION}-${FULL_CHANNEL}.dmg"

          if [ -f "$DMG_FILE" ]; then
            echo "Uploading DMG to S3 for channel: $FULL_CHANNEL..."
            # Upload versioned DMG
            aws s3 cp "$DMG_FILE" "s3://griptape-nodes-desktop-releases/${USER_CHANNEL}/GriptapeNodes-${VERSION}-${FULL_CHANNEL}.dmg"
            # Upload latest DMG (without version number for stable URL)
            aws s3 cp "$DMG_FILE" "s3://griptape-nodes-desktop-releases/${USER_CHANNEL}/GriptapeNodes-${FULL_CHANNEL}.dmg"
          else
            echo "Warning: DMG file not found: $DMG_FILE"
          fi
        shell: bash

      - name: Upload Setup.exe to S3 (Windows only)
        if: env.DONE != 'true' && runner.os == 'Windows' && needs.validate.outputs.skip_s3_upload != 'true'
        run: |
          VERSION=$(node -p "require('./package.json').version")
          SETUP_FILE="Releases/GriptapeNodes-${VERSION}-${FULL_CHANNEL}-Setup.exe"

          if [ -f "$SETUP_FILE" ]; then
            echo "Uploading Setup.exe to S3 for channel: $FULL_CHANNEL..."
            # Upload versioned Setup.exe
            aws s3 cp "$SETUP_FILE" "s3://griptape-nodes-desktop-releases/${USER_CHANNEL}/GriptapeNodes-${VERSION}-${FULL_CHANNEL}-Setup.exe"
            # Upload latest Setup.exe (without version number for stable URL)
            aws s3 cp "$SETUP_FILE" "s3://griptape-nodes-desktop-releases/${USER_CHANNEL}/GriptapeNodes-${FULL_CHANNEL}-Setup.exe"
          else
            echo "Warning: Setup.exe file not found: $SETUP_FILE"
          fi
        shell: bash

      - name: Clean up keychain
        if: runner.os == 'macOS' && always() && steps.install_certs.outcome == 'success'
        run: security delete-keychain $RUNNER_TEMP/app-signing.keychain-db

      - name: Upload GitHub Release Assets
        if: env.DONE != 'true'
        uses: actions/upload-artifact@v4
        with:
          name: releases-${{ env.OS }}-${{ env.ARCH }}
          path: Releases/

  create-github-release:
    needs: [validate, release]
    runs-on: ubuntu-latest
    if: success()

    permissions:
      contents: write

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4
        with:
          ref: ${{ github.ref }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '24'

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts

      - name: Create unified GitHub release
        run: |
          VERSION=$(node -p "require('./package.json').version")
          USER_CHANNEL="${{ needs.validate.outputs.channel }}"
          SKIP_S3="${{ needs.validate.outputs.skip_s3_upload }}"

          # Construct release tag, name, and flags based on channel
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            TAG_NAME="v${VERSION}"
            RELEASE_NAME="Griptape Nodes Desktop ${VERSION}"
            PRERELEASE_FLAG=""
          else
            TAG_NAME="v${VERSION}-${USER_CHANNEL}"
            RELEASE_NAME="[TEST] Griptape Nodes Desktop ${VERSION} (${USER_CHANNEL})"
            PRERELEASE_FLAG="--prerelease"
          fi

          echo "Creating unified release: $TAG_NAME"
          echo "Release name: $RELEASE_NAME"
          echo "Prerelease: ${PRERELEASE_FLAG:-no}"
          echo "S3 upload skipped: $SKIP_S3"

          # Find the full installers from each platform
          MACOS_DMG=$(find artifacts/releases-osx-arm64 -name "GriptapeNodes-*.dmg" 2>/dev/null | head -1)
          LINUX_X64_APPIMAGE=$(find artifacts/releases-linux-x64 -name "*.AppImage" 2>/dev/null | head -1)
          LINUX_ARM64_APPIMAGE=$(find artifacts/releases-linux-arm64 -name "*.AppImage" 2>/dev/null | head -1)
          WINDOWS_SETUP=$(find artifacts/releases-win-* -name "*-Setup.exe" 2>/dev/null | head -1)

          # Debug: list all artifacts
          echo "=== All artifacts ==="
          find artifacts -type f -name "*.dmg" -o -name "*.AppImage" -o -name "*-Setup.exe" 2>/dev/null || true
          echo "=== Found installers ==="
          echo "MACOS_DMG: $MACOS_DMG"
          echo "LINUX_X64_APPIMAGE: $LINUX_X64_APPIMAGE"
          echo "LINUX_ARM64_APPIMAGE: $LINUX_ARM64_APPIMAGE"
          echo "WINDOWS_SETUP: $WINDOWS_SETUP"

          # Create release notes content with separator for app parsing
          # The separator allows the app to extract just the changelog section
          if [[ "$USER_CHANNEL" == "stable" ]]; then
            INSTALL_NOTES=$(cat <<'EOF'
          <!-- release-notes-separator -->

          ## Installation

          Download the installer for your platform:
          - **macOS (Apple Silicon)**: Download the .dmg file
          - **Linux x64**: Download the linux-x64 .AppImage file
          - **Linux ARM64**: Download the linux-arm64 .AppImage file
          - **Windows**: Download the Setup.exe file

          ## Updates

          This application includes automatic updates.
          EOF
          )
          else
            INSTALL_NOTES=$(cat <<'EOF'
          > **Warning**: This is a test build from a non-main branch.
          > Auto-updates are not available for this build.
          > This build should not be used in production.

          <!-- release-notes-separator -->

          ## Installation

          Download the installer for your platform:
          - **macOS (Apple Silicon)**: Download the .dmg file
          - **Linux x64**: Download the linux-x64 .AppImage file
          - **Linux ARM64**: Download the linux-arm64 .AppImage file
          - **Windows**: Download the Setup.exe file

          ## Updates

          This is a test build. Auto-updates are not available.
          EOF
          )
          fi

          # Create the release with all available installers
          # --generate-notes creates changelog from PRs, --notes appends installation instructions
          gh release create "$TAG_NAME" \
            --target "${{ github.sha }}" \
            --title "$RELEASE_NAME" \
            --generate-notes \
            --notes "$INSTALL_NOTES" \
            $PRERELEASE_FLAG \
            ${MACOS_DMG:+"$MACOS_DMG"} \
            ${LINUX_X64_APPIMAGE:+"$LINUX_X64_APPIMAGE"} \
            ${LINUX_ARM64_APPIMAGE:+"$LINUX_ARM64_APPIMAGE"} \
            ${WINDOWS_SETUP:+"$WINDOWS_SETUP"}

          echo "GitHub release created successfully!"
        shell: bash
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
